import sys
import os

import cv2
import glob
import numpy as np
from matplotlib.patches import Circle

from PyQt5 import QtWidgets, QtGui

from package.gui.guidesign import Ui_MainWindow

from filter.data import Data

class DesignerMainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    """Customization for Qt Designer created window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)

        self.statusbar.showMessage('Ready', 10000)

        # File Menu signals
        self.actionSingle.triggered.connect(self.select_file)
        self.actionDirectory.triggered.connect(self.select_dir)

        # push button signals
        self.pbImageOpen.clicked.connect(self.select_file)
        self.pbUpdate.clicked.connect(self.update_graph)
        self.pbExport.clicked.connect(self.export_image)
        self.pbDirectoryOpen.clicked.connect(self.select_dir)
        self.pbDirectoryExport.clicked.connect(self.select_dir)
        self.pbRun.clicked.connect(self.run_export)

    def select_file(self):
        """opens a file select dialog and plots file"""
        self.statusbar.showMessage('Loading Image', 20000)

        # open file select dialog
        if self.lineEditImage.text() == '' or self.sender().text() == 'Open Image':
            # open the dialog and get the selected file
            file = QtWidgets.QFileDialog.getOpenFileName(self, 'Select Image')
            self.lineEditImage.setText(file[0])
            self.tabWidget.setCurrentIndex(0)

        # try to plot input, raise Error if not an image
        try:
            self.initial_plot()
        except:
            self.statusbar.showMessage('ERROR: File has to be an image. Try JPG or PNG Type.')

    def select_dir(self):
        """opens directory selection dialog"""
        directory = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select directory')
        if self.sender().text() == 'Export':
            self.lineEditDirOut.setText(directory)
        else:
            self.lineEditDirIn.setText(directory)
            self.tabWidget.setCurrentIndex(1)

    def parse_file(self, filename):
        """ initiates image as an object of data class."""
        a = Data(filename)
        return a

    def plot(self, image):
        # clear the Axes
        self.mpl.canvas.ax.clear()
        # plot image
        self.mpl.canvas.ax.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        self.mpl.canvas.ax.axis('off')
        # force an image redraw
        self.mpl.canvas.draw()
        self.statusbar.clearMessage()

    def initial_plot(self):
        a = self.parse_file(self.lineEditImage.text())
        self.plot(a.img)

    def update_graph(self):
        self.statusbar.showMessage('update is running...')
        a = self.parse_file(self.lineEditImage.text())
        # collect values from user input
        percent= self.sbCrop.value()
        lowsize = self.sbBlob.value()
        a.filter(percent, lowsize)

        if self.cbYellow.isChecked() == True:
            self.plot(a.blob)

        elif self.cbCircle.isChecked() == True or self.cbDead.isChecked() == True:
            self.mpl.canvas.ax.clear()
            self.mpl.canvas.ax.set_aspect('equal')

            if self.cbCircle.isChecked() == True:
                number, output, stats, centroids = cv2.connectedComponentsWithStats(a.blob[:, :, 0], connectivity=8)
                center = list(zip(centroids[1:, 0].astype(int), centroids[1:, 1].astype(int)))
                radius = stats[1:, 3]

                self.mpl.canvas.ax.imshow(cv2.cvtColor(a.cropped, cv2.COLOR_BGR2RGB))
                self.mpl.canvas.ax.axis("off")
                counter = 0
                for i in range(centroids[1:, 1].shape[0]):
                    circ = Circle(center[i], radius[i], color="r", linewidth=1, fill=False)
                    self.mpl.canvas.ax.add_patch(circ)
                    counter += 1
                self.statusbar.showMessage('{} Flowers counted.'.format(counter))
            else:
                minBGR = np.array((0, 133, 200))
                maxBGR = np.array((55, 160, 220))
                maskBGR = cv2.inRange(a.blob, minBGR, maxBGR)

                number, output, stats, centroids = cv2.connectedComponentsWithStats(maskBGR, connectivity=8)
                center = list(zip(centroids[1:, 0].astype(int), centroids[1:, 1].astype(int)))
                radius = stats[1:, 3]

                self.mpl.canvas.ax.imshow(cv2.cvtColor(a.blob, cv2.COLOR_BGR2RGB))
                self.mpl.canvas.ax.axis("off")


                for i in range(centroids[1:, 1].shape[0]):
                    circ = Circle(center[i], radius[i], color="m", linewidth=1, fill=False)
                    self.mpl.canvas.ax.add_patch(circ)

            self.mpl.canvas.draw()

        else:
            a.crop(percent)
            self.plot(a.cropped)

    def export_image(self):
        self.statusbar.showMessage('export is running...')
        a = self.parse_file(self.lineEditImage.text())

        # collect values from user input
        percent= self.sbCrop.value()
        lowsize = self.sbBlob.value()

        saveas = QtWidgets.QFileDialog.getSaveFileName(self, 'Save as')[0]

        if self.cbYellow.isChecked() == True:
            # apply filter
            a.filter(percent, lowsize)
            # plot result
            try:
                cv2.imwrite(saveas, a.blob)
            except:
                self.statusbar.showMessage("ERROR: Not a valid file name. File type has to be JPG or PNG.")
            else:
                self.statusbar.clearMessage()
        else:
            a.crop(percent)
            try:
                cv2.imwrite(saveas, a.cropped)
            except:
                self.statusbar.showMessage("ERROR: Not a valid file name. File type has to be JPG or PNG.")
            else:
                self.statusbar.clearMessage()

    def run_export(self):
        # list of images
        path = self.lineEditDirIn.text() + '/*.*'
        paths = glob.glob(path)

        # create output directory if necessary
        outputdir = self.lineEditDirOut.text() + '/'
        os.makedirs(outputdir, exist_ok= True)

        # set value of progressbar
        self.completed = 0
        self.total = len(paths)

        # collect values from user input
        percent = self.sbCropDir.value()
        lowsize = self.sbBlobDir.value()

        if self.cbYellowDir.isChecked() == True:
            for imagepath in paths:
                a = self.parse_file(imagepath)
                a.filter(percent, lowsize)
                outpath = outputdir + a.name + 'seg' + str(lowsize) + '.png'
                cv2.imwrite(outpath, a.blob)
                if self.completed < 100:
                    self.completed += 100/self.total
                    self.progressBar.setValue(self.completed)
        else:
            for imagepath in paths:
                a = self.parse_file(imagepath)
                a.crop(percent)
                outpath = outputdir+ a.name + 'crop' + str(percent) + '.png'
                cv2.imwrite(outpath, a.cropped)
                if self.completed < 100:
                    self.completed += 100/self.total
                    self.progressBar.setValue(self.completed)
        # ...same for deadflowers checkbox



# create the GUI application
app = QtWidgets.QApplication(sys.argv)
# instantiate the main window
dmw = DesignerMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())

